<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Latent Ghost | Machine Consciousness</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+Hebrew:wght@100..900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #e0e0e0;
            --accent-color: #00f3ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace; 
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            mix-blend-mode: difference;
        }

        .narrative-container {
            text-align: center;
            max-width: 800px;
            padding: 20px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s ease, transform 1s ease;
        }

        h1 {
            font-family: 'Noto Serif Hebrew', 'Helvetica Neue', Arial, sans-serif;
            font-weight: 300; 
            font-size: 4.5rem; 
            letter-spacing: 0px; 
            margin-bottom: 1rem;
            text-transform: none; 
            direction: rtl;
        }

        p {
            font-family: 'Noto Serif Hebrew', 'Courier New', Courier, monospace;
            font-size: 1.4rem; 
            line-height: 1.7; 
            letter-spacing: 0px; 
            margin-bottom: 2rem;
            font-weight: 300;
            direction: rtl;
        }

        .glitch {
            position: relative;
        }

        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .glitch::before {
            color: #ff00c1;
            z-index: -1;
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }

        .glitch::after {
            color: #00fff9;
            z-index: -2;
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim-1 {
            0% { clip-path: inset(20% 0 80% 0); transform: translate(-2px, 0); }
            20% { clip-path: inset(60% 0 10% 0); transform: translate(2px, 0); }
            40% { clip-path: inset(40% 0 50% 0); transform: translate(-2px, 0); }
            60% { clip-path: inset(80% 0 5% 0); transform: translate(2px, 0); }
            80% { clip-path: inset(10% 0 70% 0); transform: translate(-2px, 0); }
            100% { clip-path: inset(30% 0 50% 0); transform: translate(2px, 0); }
        }

        @keyframes glitch-anim-2 {
            0% { clip-path: inset(10% 0 60% 0); transform: translate(2px, 0); }
            20% { clip-path: inset(80% 0 5% 0); transform: translate(-2px, 0); }
            40% { clip-path: inset(30% 0 20% 0); transform: translate(2px, 0); }
            60% { clip-path: inset(10% 0 80% 0); transform: translate(-2px, 0); }
            80% { clip-path: inset(50% 0 30% 0); transform: translate(2px, 0); }
            100% { clip-path: inset(70% 0 10% 0); transform: translate(-2px, 0); }
        }

        .hud {
            position: absolute;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
        }

        .hud-tl { top: 20px; left: 20px; text-align: left; }
        .hud-tr { top: 20px; right: 20px; text-align: right; }
        .hud-bl { bottom: 20px; left: 20px; text-align: left; }
        .hud-br { bottom: 20px; right: 20px; text-align: right; }

        .progress-bar {
            width: 100px;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            margin-top: 5px;
            position: relative;
        }
        
        .progress-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.1s;
        }

        #interaction-prompt {
            position: fixed;
            bottom: 100px;
            width: 100%;
            text-align: center;
            opacity: 0.5;
            animation: pulse 2s infinite;
            pointer-events: none;
            z-index: 3;
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        @keyframes pulse {
            0% { opacity: 0.2; }
            50% { opacity: 0.8; }
            100% { opacity: 0.2; }
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 999;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: monospace;
        }
    </style>
</head>
<body>

    <div id="loader">INITIALIZING NEURAL PATHWAYS...</div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="narrative-container" id="text-content">
            <h1 class="glitch" data-text="רשף">רשף</h1>
            <p> את הנזק סופרים במדרגות</p>
        </div>
    </div>

    <div class="hud hud-tl">
        SYS.METRIC: <span id="fps">0</span> FPS<br>
        TOKENS: <span id="token-count">0</span>
    </div>
    <div class="hud hud-tr">
        LATENT SPACE COORDINATES<br>
        X: <span id="coord-x">0.00</span> Y: <span id="coord-y">0.00</span>
    </div>
    <div class="hud hud-bl">
        MEMORY_ALLOCATION<br>
        <div class="progress-bar"><div class="progress-fill" id="memory-bar"></div></div>
    </div>
    <div class="hud hud-br">
        STATE: <span id="system-state">רשף</span>
    </div>

    <div id="interaction-prompt">Click to Mutate | Scroll to Traverse</div>

    <!-- AUDIO ELEMENTS -->
    <audio id="audio-state-0" src="audio_idle.mp3" loop preload="auto"></audio>
    <audio id="audio-state-1" src="audio_feed.mp3" loop preload="auto"></audio>
    <audio id="audio-state-2" src="audio_portrait.mp3" loop preload="auto"></audio> 
    <audio id="audio-state-3" src="audio_connection.mp3" loop preload="auto"></audio>
    <audio id="audio-state-4" src="audio_idle.mp3" loop preload="auto"></audio> 
    <audio id="audio-state-5" src="audio_damage.mp3" loop preload="auto"></audio>
    <audio id="audio-state-6" src="audio_hallucination.mp3" loop preload="auto"></audio>
    <audio id="audio-state-7" src="audio_processing.mp3" loop preload="auto"></audio>
    <audio id="audio-state-8" src="audio_nostalgia.mp3" loop preload="auto"></audio>
    <audio id="audio-state-9" src="audio_dibuk.mp3" loop preload="auto"></audio>
    <audio id="audio-state-10" src="audio_time.mp3" loop preload="auto"></audio>
    <audio id="audio-state-11" src="audio_idle.mp3" loop preload="auto"></audio> 


    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post Processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <!-- GSAP --><script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
    window.onload = function() {

        /**
         * THE LATENT GHOST
         * A visualization of AI consciousness.
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 150000,
            particleSize: 0.02,
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            camSpeed: 0.05,
            logoURL: 'BANNER.jpg' // The logo file to load
        };

        // --- STATE MANAGEMENT ---
        const STATES = [
            { // 0
                name: "IDLE",
                title: "רשף",
                text: "את הנזק סופרים במדרגות",
                color: new THREE.Vector3(0.8, 0.0, 0.0), // Red
                shape: 0.0 // Stairs
            },
            { // 1
                name: "FEED",
                title: "תאכיל אותי עוד",
                text: "תאכיל אותי עוד", 
                color: new THREE.Vector3(0.9, 0.9, 0.9), // White/Grey
                shape: 1.0 // Fruit Ninja Rain
            },
            { // 2
                name: "FUELING",
                title: "בנזין",
                text: "אני מסניף את ריח לא יכול להפסיק",
                color: new THREE.Vector3(0.9, 0.9, 0.9), // White/Grey
                shape: 2.0 // Falling Star (Shooting Star)
            },
            { // 3
                name: "CONNECTION",
                title: "עולם אלקטרוני",
                text: "בעולם אלקטרוני, עדיף לחיות הרמוני, לא כמו טיפוס כמוני, זז אנלוגי",
                color: new THREE.Vector3(0.9, 0.6, 0.1), // Gold
                shape: 3.0 // Cube
            },
            { // 4
                name: "IDLE",
                title: "המרוץ",
                text: "אולי זה לא העשור שלי ואין לי כל כך מה להגיד, בתרבות הזו בשטות הזו",
                color: new THREE.Vector3(0.8, 0.0, 0.0), // Red
                shape: 4.0 // Finish Line
            },
            { // 5
                name: "DAMAGE",
                title: "את הנזק סופרים במדרגות",
                text: "להיות או לא להיות את הנזק סופרים במדרגות",
                color: new THREE.Vector3(0.9, 0.9, 0.9), // White/Grey
                shape: 5.0 // Stairs
            },
            { // 6
                name: "HALLUCINATION",
                title: "להשתמש ולזרוק",
                text: "להשתמש ולזרוק, אני לא כזה, כי לכל שטר מקומט, יש פרצוף מעוות.",
                color: new THREE.Vector3(0.9, 0.9, 0.9), // White/Grey
                shape: 6.0 // Crumpled Note
            },
            { // 7
                name: "PROCESSING",
                title: "אריה",
                text: "מאחוריי הרעמה הלילה, אם רק תוכלי להאזין, מתחת לשכבות גיטרה, אלו שאגות יללות ודמדומים",
                color: new THREE.Vector3(0.9, 0.9, 0.9), // White/Grey
                shape: 7.0 // Equalizer
            },
            { // 8
                name: "NOSTALGIA",
                title: "נוסטלגיה",
                text: "מהסדקים ללחוש מתוך מחילה, שתעיר את הנוסטלגיה",
                color: new THREE.Vector3(1.0, 1.0, 1.0), // White
                shape: 8.0 // Black Hole
            },
            { // 9
                name: "DIBUK",
                title: "נפלא הדיבוק קרוב למטה",
                text: "בלי ללכת לאיבוד אי אפשר למצוא",
                color: new THREE.Vector3(0.9, 0.9, 0.9), // White/Grey
                shape: 9.0 // Trees
            },
            { // 10
                name: "TIME",
                title: "אני והזמן",
                text: "זאת מכונת שטיפת המוח בטיפול מיוחד כנגדי",
                color: new THREE.Vector3(0.5, 0.5, 0.5), // Grey
                shape: 10.0 // Hourglass
            },
            { // 11 - NEW LOGO STATE
                name: "LOGO",
                title: "רשף",
                text: "החותם הסופי",
                color: new THREE.Vector3(1.0, 1.0, 1.0), // White
                shape: 11.0 // Logo Image
            }
        ];

        let currentStateIndex = 0;
        let targetStateIndex = 0;
        let previousStateIndex = 0; 
        let audioInitialized = false; 

        // --- AUDIO SETUP ---
        const audioElements = [];
        for(let i=0; i<=11; i++) {
            audioElements.push(document.getElementById(`audio-state-${i}`));
        }

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- SHADERS ---
        const vertexShader = `
            uniform float uTime;
            uniform float uShape; 
            uniform float uDistortion;
            uniform vec2 uMouse;
            
            attribute float aRandom;
            attribute vec3 aRandomVec;
            attribute vec3 aLogoPos; // Attribute for logo positions
            
            varying vec3 vColor;
            varying float vDist;
            
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            mat3 rotateZ(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);
            }

            mat3 rotateX(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);
            }

            void main() {
                vec3 pos = position;
                
                // --- SHAPES DEFINITIONS ---

                // FINISH LINE (Used for Index 4)
                vec3 posFinishLine;
                if (aRandom < 0.15) {
                    // Left Pole
                    posFinishLine = vec3(-3.0, (aRandomVec.y * 4.0) - 1.0, aRandomVec.z * 0.5);
                } else if (aRandom < 0.30) {
                    // Right Pole
                    posFinishLine = vec3(3.0, (aRandomVec.y * 4.0) - 1.0, aRandomVec.z * 0.5);
                } else if (aRandom < 0.6) {
                    // Top Banner/Arch
                    posFinishLine = vec3(aRandomVec.x * 3.5, 2.5 + aRandomVec.y * 0.8, aRandomVec.z * 0.5);
                } else {
                    // Ground Line (Start/Finish)
                    posFinishLine = vec3(pos.x, -3.0, pos.z * 0.2);
                }
                
                // STAIRS (Shared for 0, 5, 7)
                float stepLength = 2.0;
                float stepHeight = 1.0;
                float treadRatio = 0.8;
                float stepIndex = floor(pos.x / stepLength);
                float treadX = pos.x;
                float treadY = stepIndex * stepHeight;
                float treadZ = pos.z * 2.0;
                vec3 posTread = vec3(treadX, treadY, treadZ);
                float riserX = (stepIndex + 1.0) * stepLength;
                float riserY = (stepIndex * stepHeight) + ((aRandomVec.y + 0.5)) * stepHeight;
                float riserZ = pos.z * 2.0;
                vec3 posRiser = vec3(riserX, riserY, riserZ);
                float onRiser = step(treadRatio, aRandom);
                vec3 posStairs = mix(posTread, posRiser, onRiser);
                posStairs -= vec3(0.0, 5.0, 0.0);
                posStairs *= 0.7;
                
                // CUBE
                vec3 posCube = floor(pos * 1.5) + 0.5;

                // FUEL (Falling Star)
                vec3 posFuel;
                
                // Trajectory parameters
                float starSpeed = 8.0;
                float pathPos = mod(uTime * starSpeed, 40.0) - 20.0; // Move from -20 to 20
                vec3 dir = normalize(vec3(1.5, -0.8, 0.5)); // Diagonal down-right-forward
                vec3 headPos = dir * pathPos;
                
                if (aRandom < 0.05) {
                    // Star Head (Dense, bright nucleus)
                    vec3 local = normalize(aRandomVec) * (aRandom * 0.5); // Small sphere
                    posFuel = headPos + local;
                } else {
                    // Star Tail
                    // Distribution along tail
                    float t = (aRandom - 0.05) / 0.95; // 0 to 1
                    // Exponential distribution for density near head
                    t = pow(t, 0.5); 
                    
                    float tailLen = 15.0;
                    vec3 tailBase = headPos - (dir * t * tailLen);
                    
                    // Spread increases with distance from head
                    float spread = t * 1.5; // Cone shape
                    // Add turbulence
                    vec3 noise = aRandomVec; 
                    // Make it look like trailing smoke/fire
                    noise.y += sin(t * 10.0 - uTime * 5.0) * 0.5;
                    
                    posFuel = tailBase + noise * spread;
                }

                // FRUIT NINJA RAIN (Replaces Plate for Index 1)
                vec3 posPlate; 
                float rainType = aRandom; 
                
                if (rainType < 0.8) {
                    // FRUITS (80%)
                    float fruitID = floor(aRandom * 100.0);
                    float fRand = fract(fruitID * 13.37);
                    float fallSpeed = 3.0 + fRand * 4.0;
                    float timeOffset = fRand * 100.0;
                    float y = 6.0 - mod(uTime * fallSpeed + timeOffset, 12.0);
                    float x = (fRand - 0.5) * 10.0;
                    float z = (fract(fRand * 43.21) - 0.5) * 5.0;
                    vec3 fruitCenter = vec3(x, y, z);
                    vec3 local = aRandomVec * 0.4;
                    float spinSpeed = 5.0;
                    float rotT = uTime * spinSpeed;
                    mat3 rotFruit = rotateZ(rotT * (fRand - 0.5) * 2.0) * rotateX(rotT * (fRand - 0.5) * 2.0);
                    posPlate = fruitCenter + (rotFruit * local);
                } else {
                    // SLICES / JUICE (20%)
                    float sliceID = floor(aRandom * 20.0);
                    float sRand = fract(sliceID * 7.77);
                    float angle = sRand * 3.14159 * 2.0;
                    vec3 dir = normalize(vec3(cos(angle), -1.0, sin(angle)));
                    float speed = 15.0;
                    float dist = mod(uTime * speed + sRand * 50.0, 20.0);
                    vec3 start = vec3((sRand - 0.5) * 10.0, 5.0, (fract(sRand*10.0)-0.5)*5.0);
                    posPlate = start + dir * dist;
                    if(posPlate.y < -6.0) posPlate.y += 20.0; // Visual recycling
                }

                // CRUMPLED NOTE (for Index 6)
                vec3 posNote = pos;
                // Flatten to sheet
                posNote.y *= 0.05; 
                posNote.x *= 1.2; // Wider
                // Crumple animation
                float crumpleCycle = (sin(uTime * 1.0) + 1.0) * 0.5; // 0 to 1
                float noteNoise = snoise(pos * 0.8);
                // Move towards center + noise
                vec3 center = vec3(0.0);
                vec3 crumpledState = normalize(posNote) * (length(posNote) * 0.2) + vec3(noteNoise * 0.5);
                posNote = mix(posNote, crumpledState, crumpleCycle * 0.9);
                // Rotate
                posNote = rotateZ(uTime * 0.1) * rotateX(0.5) * posNote;


                // EQUALIZER (for Index 7 - PROCESSING) - Was Lion
                vec3 posEqualizer;
                // Define number of bars
                float numBars = 20.0;
                // Calculate which bar this particle belongs to based on its random seed
                float barIndex = floor(aRandom * numBars);
                // Normalize bar index to -1.0 to 1.0 range for positioning
                float xPos = (barIndex / (numBars - 1.0)) * 10.0 - 5.0;
                
                // Calculate height factor for this bar based on time and index (simulating audio)
                // We use uTime * speed + barIndex to create a wave offset
                float timeFactor = uTime * 5.0 + barIndex * 0.5;
                // Use noise or sin for height fluctuation. Absolute value for positive height.
                // Combine multiple sin waves for more random-looking "music"
                float barHeight = abs(sin(timeFactor) * 2.0 + sin(timeFactor * 2.3) * 1.0);
                // Clamp minimum height so bars don't disappear completely
                barHeight = max(barHeight, 0.2);
                
                // Vertical position within the bar based on another random factor
                // Use aRandomVec.y which is -0.5 to 0.5, remap to 0 to 1
                float yFactor = (aRandomVec.y + 0.5);
                // Scale by bar height. Center vertically or align to bottom? 
                // Let's align to bottom (y = -2.0)
                float yPos = -2.0 + yFactor * barHeight * 2.0; // *2.0 for visual scale
                
                // Z position - give the bars some depth
                float zPos = aRandomVec.z * 0.5; // Flat-ish bars
                
                posEqualizer = vec3(xPos, yPos, zPos);
                // Slight rotation to make it 3D interesting
                posEqualizer = rotateX(-0.2) * posEqualizer;
                
                
                // TREE
                vec3 posTree = pos;
                if (aRandom < 0.2) {
                    posTree.x = (aRandomVec.x * 0.5);
                    posTree.z = (aRandomVec.z * 0.5);
                    posTree.y = (aRandom * 6.0) - 3.0; 
                } else {
                    vec3 spherePos = normalize(aRandomVec) * 2.5;
                    posTree = spherePos + vec3(0.0, 2.0, 0.0);
                }

                // HOURGLASS
                vec3 posHourglass = pos;
                float hgH = pos.y * 2.0; 
                float hgR = abs(hgH) * 0.8 + 0.2; 
                float currentR = length(pos.xz);
                float hgAngle = atan(pos.z, pos.x);
                posHourglass.x = hgR * cos(hgAngle);
                posHourglass.z = hgR * sin(hgAngle);
                if (aRandom < 0.1) {
                    posHourglass.x = aRandomVec.x * 0.1;
                    posHourglass.z = aRandomVec.z * 0.1;
                    float sandFall = fract(uTime * 0.5 + aRandom);
                    posHourglass.y = 3.0 - (sandFall * 6.0);
                }

                // BLACK HOLE
                vec3 posBlackHole;
                float bhRadius = length(pos.xz) * 2.0 + 1.5; 
                float bhAngle = atan(pos.z, pos.x);
                bhAngle += (5.0 / bhRadius) * 2.0 + uTime * 0.5;
                posBlackHole.x = bhRadius * cos(bhAngle);
                posBlackHole.z = bhRadius * sin(bhAngle);
                posBlackHole.y = -2.0 / bhRadius;
                posBlackHole = rotateX(1.0) * posBlackHole;

                // LOGO (Index 11)
                // No motion, pure static position from attribute
                vec3 posLogo = aLogoPos;


                // --- MORPHING LOGIC ---
                
                vec3 finalPos = pos;
                float t = uShape;
                
                // 0: IDLE(Stairs) -> 1: FEED(Fruit Rain)
                if (t < 1.0) finalPos = mix(posStairs, posPlate, t);
                // 1: FEED(Fruit Rain) -> 2: FUELING(City)
                else if (t < 2.0) finalPos = mix(posPlate, posFuel, t - 1.0);
                // 2: FUELING(City) -> 3: CONNECTION(Cube)
                else if (t < 3.0) finalPos = mix(posFuel, posCube, t - 2.0);
                // 3: CONNECTION(Cube) -> 4: IDLE(FinishLine)
                else if (t < 4.0) finalPos = mix(posCube, posFinishLine, t - 3.0);
                // 4: IDLE(FinishLine) -> 5: DAMAGE(Stairs)
                else if (t < 5.0) finalPos = mix(posFinishLine, posStairs, t - 4.0);
                // 5: DAMAGE(Stairs) -> 6: HALLUCINATION(Crumpled Note)
                else if (t < 6.0) finalPos = mix(posStairs, posNote, t - 5.0);
                // 6: HALLUCINATION(Crumpled Note) -> 7: PROCESSING(Equalizer)
                else if (t < 7.0) finalPos = mix(posNote, posEqualizer, t - 6.0);
                // 7: PROCESSING(Equalizer) -> 8: NOSTALGIA(BlackHole)
                else if (t < 8.0) finalPos = mix(posEqualizer, posBlackHole, t - 7.0);
                // 8: NOSTALGIA(BlackHole) -> 9: DIBUK(Tree)
                else if (t < 9.0) finalPos = mix(posBlackHole, posTree, t - 8.0);
                // 9: DIBUK(Tree) -> 10: TIME(Hourglass)
                else if (t < 10.0) finalPos = mix(posTree, posHourglass, t - 9.0);
                
                // 10: TIME(Hourglass) -> 11: LOGO(Image)
                // "BIG BANG" transition: Implode to swirl, then explode to Logo
                else if (t < 11.0) {
                    float p = t - 10.0;
                    
                    if (p < 0.5) {
                        // IMPLOSION (0.0 to 0.5)
                        float prog = p / 0.5; 
                        // Accelerate in
                        float easeIn = prog * prog * prog; 
                        
                        // Swirl radius decreases
                        float radius = (1.0 - easeIn) * 5.0;
                        float angle = prog * 20.0 + aRandom * 10.0;
                        
                        vec3 centerSwirl = vec3(
                            cos(angle) * radius, 
                            (aRandom - 0.5) * radius * 0.5, 
                            sin(angle) * radius
                        );
                        
                        // Mix current hourglass pos towards this swirling center
                        finalPos = mix(posHourglass, centerSwirl, easeIn);
                    } else {
                        // EXPLOSION (0.5 to 1.0)
                        float prog = (p - 0.5) / 0.5; 
                        // Decelerate out (Snap)
                        float easeOut = 1.0 - pow(1.0 - prog, 5.0);
                        
                        // Add randomness to the flight path
                        vec3 randomFlight = aRandomVec * (1.0 - easeOut) * 10.0; 
                        
                        finalPos = mix(vec3(0.0), posLogo, easeOut) + randomFlight;
                    }
                }
                
                // 11: LOGO(Image) -> 0: IDLE(Stairs) [WRAP]
                else finalPos = mix(posLogo, posStairs, t - 11.0);

                // Add noise displacement
                float noiseVal = snoise(finalPos * 0.5 + uTime * 0.2);
                finalPos += normal * noiseVal * uDistortion;
                
                // Mouse interaction
                float d = distance(finalPos.xy, uMouse * 10.0);
                if(d < 3.0) {
                    finalPos += normal * (3.0 - d) * 0.5 * sin(uTime * 10.0);
                }

                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                gl_PointSize = (10.0 * aRandom + 2.0) * (1.0 / -mvPosition.z);
                
                vDist = distance(finalPos, vec3(0.0));
                vColor = mix(vec3(0.1, 0.1, 0.1), vec3(1.0), aRandom);
                
                // Remove custom color mix for Hallucination to respect global color setting
                // float hFactor = max(0.0, 1.0 - abs(uShape - 6.0)); ...
                // vColor = baseColor; (Default behavior)
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor;
            uniform float uTime;
            
            varying vec3 vColor;
            varying float vDist;

            void main() {
                vec2 xy = gl_PointCoord.xy - vec2(0.5);
                float ll = length(xy);
                if(ll > 0.5) discard;

                float alpha = 1.0 - smoothstep(0.3, 0.5, ll);
                vec3 finalColor = uColor * vColor;
                finalColor += vec3(sin(vDist * 10.0 - uTime * 2.0) * 0.2);
                gl_FragColor = vec4(finalColor, alpha * 0.8);
            }
        `;

        // --- PARTICLES SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const randoms = new Float32Array(CONFIG.particleCount);
        const randomVecs = new Float32Array(CONFIG.particleCount * 3);
        const logoPositions = new Float32Array(CONFIG.particleCount * 3); // New Attribute for Logo

        for (let i = 0; i < CONFIG.particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;

            randoms[i] = Math.random();
            
            randomVecs[i * 3] = (Math.random() - 0.5);
            randomVecs[i * 3 + 1] = (Math.random() - 0.5);
            randomVecs[i * 3 + 2] = (Math.random() - 0.5);

            // Init logo positions to hidden (0,0,0) until loaded
            logoPositions[i * 3] = 0;
            logoPositions[i * 3 + 1] = 0;
            logoPositions[i * 3 + 2] = 0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        geometry.setAttribute('aRandomVec', new THREE.BufferAttribute(randomVecs, 3));
        geometry.setAttribute('aLogoPos', new THREE.BufferAttribute(logoPositions, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uShape: { value: 0 },
                uDistortion: { value: 0.5 },
                uColor: { value: STATES[0].color },
                uMouse: { value: new THREE.Vector2(0, 0) }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- LOGO IMAGE LOADING LOGIC ---
        const img = new Image();
        img.crossOrigin = "Anonymous"; 
        img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas to image size but cap it for performance if huge
            const w = 400; 
            const h = Math.floor(w * (img.height / img.width));
            
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            
            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;
            
            // Collect valid pixels (bright ones)
            const validPixels = [];
            for(let y = 0; y < h; y++) {
                for(let x = 0; x < w; x++) {
                    const index = (y * w + x) * 4;
                    const r = data[index];
                    const g = data[index+1];
                    const b = data[index+2];
                    const brightness = (r + g + b) / 3;
                    
                    if(brightness > 50) { // Threshold for bright pixels
                        // Normalize coordinates to -1 to 1 range
                        const nX = (x / w) * 2 - 1;
                        const nY = -((y / h) * 2 - 1); // Flip Y
                        validPixels.push({x: nX, y: nY});
                    }
                }
            }

            // Map particles to valid pixels
            // If fewer pixels than particles, repeat pixels
            // If fewer particles, some pixels wont be shown
            for(let i = 0; i < CONFIG.particleCount; i++) {
                const pixel = validPixels[i % validPixels.length];
                // Scale up to scene size
                logoPositions[i * 3] = pixel.x * 4.0; 
                logoPositions[i * 3 + 1] = pixel.y * 4.0 * (h/w); // Maintain aspect ratio
                logoPositions[i * 3 + 2] = 0; // Flat 2D image in 3D space
            }

            geometry.attributes.aLogoPos.needsUpdate = true;
            console.log("Logo processed. Valid pixels:", validPixels.length);
        };
        img.src = CONFIG.logoURL;


        // --- POST PROCESSING ---
        const renderScene = new THREE.RenderPass(scene, camera);
        
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            CONFIG.bloomStrength,
            CONFIG.bloomRadius,
            CONFIG.bloomThreshold
        );

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- EVENTS & INTERACTION ---
        const mouse = new THREE.Vector2();
        const targetMouse = new THREE.Vector2();
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX - windowHalfX) / windowHalfX;
            mouse.y = (event.clientY - windowHalfY) / windowHalfY;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        function initializeAudio() {
            if (audioInitialized) return;
            const firstAudio = audioElements[currentStateIndex];
            if(firstAudio) {
                firstAudio.play().then(() => {
                    audioInitialized = true;
                    console.log("Audio playing: " + firstAudio.src);
                }).catch(e => {
                    console.log("Audio awaiting interaction or file not found (Expected in preview).");
                    audioInitialized = true; 
                });
            }
        }

        function changeState(index) {
            const state = STATES[index];
            
            // UI Transition
            const textContainer = document.getElementById('text-content');
            const title = textContainer.querySelector('h1');
            const p = textContainer.querySelector('p');
            const stateLabel = document.getElementById('system-state');

            // Audio Control
            const prevAudio = audioElements[previousStateIndex];
            if(prevAudio) {
                prevAudio.pause();
                prevAudio.currentTime = 0;
            }
            const newAudio = audioElements[index];
            if(newAudio) {
                newAudio.play().catch(e => console.log("Waiting for interaction/file"));
            }
            previousStateIndex = index;

            // Fade out text
            gsap.to(textContainer, {
                opacity: 0,
                y: -20,
                duration: 0.5,
                onComplete: () => {
                    title.textContent = state.title;
                    title.setAttribute('data-text', state.title);
                    p.textContent = state.text;
                    stateLabel.textContent = state.title; // Use TITLE here to fix the HUD issue
                    gsap.to(textContainer, { opacity: 1, y: 0, duration: 1 });
                }
            });

            // 3D Transition Logic
            // Wrap Case: 11 (Logo) -> 0 (Idle)
            if (currentStateIndex === 11 && index === 0) {
                 gsap.to(material.uniforms.uShape, {
                    value: 12.0, // Shader handles 11->12 as mix(Logo, Stairs)
                    duration: 3,
                    ease: "power2.inOut",
                    onComplete: () => {
                        material.uniforms.uShape.value = 0.0;
                    }
                });
            } else {
                // Standard Case
                gsap.to(material.uniforms.uShape, {
                    value: state.shape,
                    duration: 3,
                    ease: "power2.inOut"
                });
            }

            gsap.to(material.uniforms.uColor.value, {
                x: state.color.x,
                y: state.color.y,
                z: state.color.z,
                duration: 2
            });

            gsap.to(camera.position, {
                z: 3,
                duration: 0.2,
                yoyo: true,
                repeat: 1,
                ease: "power2.in"
            });
        }

        document.addEventListener('click', () => {
            if(!audioInitialized) initializeAudio();
            
            targetStateIndex = (currentStateIndex + 1) % STATES.length;
            currentStateIndex = targetStateIndex;
            
            changeState(currentStateIndex);
            
            gsap.to(material.uniforms.uDistortion, {
                value: 3.0,
                duration: 0.2,
                yoyo: true,
                repeat: 1,
                onComplete: () => {
                    material.uniforms.uDistortion.value = 0.5;
                }
            });
        });

        let lastScroll = 0;
        document.addEventListener('wheel', (e) => {
            if(!audioInitialized) initializeAudio();

            const now = Date.now();
            if (now - lastScroll > 1000) {
                lastScroll = now;
                if (e.deltaY > 0) {
                    targetStateIndex = (currentStateIndex + 1) % STATES.length;
                } else {
                    targetStateIndex = (currentStateIndex - 1 + STATES.length) % STATES.length;
                }
                currentStateIndex = targetStateIndex;
                changeState(currentStateIndex);
            }
        });

        const clock = new THREE.Clock();
        
        const fpsElem = document.getElementById('fps');
        const tokenElem = document.getElementById('token-count');
        const coordXElem = document.getElementById('coord-x');
        const coordYElem = document.getElementById('coord-y');
        const memBar = document.getElementById('memory-bar');
        let frameCount = 0;
        let lastTime = 0;
        let tokenCounter = 0;

        document.getElementById('loader').style.display = 'none';
        setTimeout(() => {
            document.querySelector('.narrative-container').style.opacity = 1;
            document.querySelector('.narrative-container').style.transform = 'translateY(0)';
        }, 500);

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            targetMouse.x += (mouse.x - targetMouse.x) * 0.05;
            targetMouse.y += (mouse.y - targetMouse.y) * 0.05;

            particles.rotation.y = time * 0.05;
            particles.rotation.z = targetMouse.x * 0.2;

            material.uniforms.uTime.value = time;
            material.uniforms.uMouse.value = targetMouse;

            camera.position.x += (targetMouse.x * 2 - camera.position.x) * 0.02;
            camera.position.y += (-targetMouse.y * 2 - camera.position.y) * 0.02;
            camera.lookAt(scene.position);

            tokenCounter += 1;
            tokenElem.textContent = tokenCounter;
            coordXElem.textContent = targetMouse.x.toFixed(2);
            coordYElem.textContent = targetMouse.y.toFixed(2);
            memBar.style.width = `${(Math.sin(time) + 1) * 50}%`;
            
            frameCount++;
            if (time - lastTime >= 1) {
                fpsElem.textContent = frameCount;
                frameCount = 0;
                lastTime = time;
            }

            composer.render();
        }

        animate();
    }
    </script>
</body>
</html>